#!/usr/bin/env python3
"""
Automated Intraday Monitoring System Builder
Builds real-time price/volatility tracking for band breach detection
"""

import os
from datetime import datetime, timedelta
import json

class IntradayMonitoringBuilder:
    def __init__(self):
        # Market symbols to monitor
        self.symbols = ["^GSPC", "^VIX", "^VVIX", "ES=F"]
        
    def create_real_time_monitor(self):
        """Generate real-time market monitoring system"""
        
        monitoring_code = '''#!/usr/bin/env python3
"""
Real-Time Market Monitoring System
Tracks SPX, VIX, VVIX, ES for band breaches and volatility alerts
Generated by automated monitoring system builder
"""

import yfinance as yf
import time
import sys
import os
from datetime import datetime, timedelta
from typing import Dict, List, Optional
import json
import requests

# Add src to path for imports
sys.path.append(os.path.join(os.path.dirname(__file__)))

try:
    from snowflake_conn import get_snowflake_connection
    SNOWFLAKE_AVAILABLE = True
except ImportError:
    print("Warning: Snowflake connection not available")
    SNOWFLAKE_AVAILABLE = False

class RealTimeMonitor:
    def __init__(self):
        self.symbols = ["^GSPC", "^VIX", "^VVIX", "ES=F"]
        self.alert_thresholds = {
            "^GSPC": {"band_breach": 0.5, "volume_spike": 2.0},  # 0.5% band breach, 2x volume
            "^VIX": {"spike": 15.0, "drop": -10.0},              # VIX % moves
            "^VVIX": {"spike": 20.0},                           # VVIX spike threshold
            "ES=F": {"band_breach": 0.5}                        # ES band breach %
        }
        self.last_alerts = {}
        
    def get_current_prices(self) -> Dict:
        """Fetch current market prices"""
        prices = {}
        
        try:
            for symbol in self.symbols:
                ticker = yf.Ticker(symbol)
                hist = ticker.history(period="2d", interval="1m")
                
                if not hist.empty:
                    current_price = hist['Close'][-1]
                    prev_close = hist['Close'][-2] if len(hist) > 1 else current_price
                    volume = hist['Volume'][-1] if 'Volume' in hist.columns else 0
                    
                    prices[symbol] = {
                        "price": current_price,
                        "prev_close": prev_close,
                        "pct_change": ((current_price - prev_close) / prev_close * 100),
                        "volume": volume,
                        "timestamp": datetime.now()
                    }
                    
        except Exception as e:
            print(f"Error fetching prices: {e}")
            
        return prices
    
    def get_forecast_bands(self) -> Dict:
        """Get today's forecast bands from database or fallback"""
        
        if SNOWFLAKE_AVAILABLE:
            try:
                conn = get_snowflake_connection()
                cursor = conn.cursor()
                
                cursor.execute("""
                SELECT FORECAST_DATE, BULL_TARGET, BEAR_TARGET, CHOP_LOWER, CHOP_UPPER
                FROM FORECAST_DAILY 
                WHERE FORECAST_DATE = CURRENT_DATE()
                ORDER BY CREATED_AT DESC
                LIMIT 1
                """)
                
                result = cursor.fetchone()
                if result:
                    return {
                        "bull_target": float(result[1]) if result[1] else None,
                        "bear_target": float(result[2]) if result[2] else None, 
                        "chop_lower": float(result[3]) if result[3] else None,
                        "chop_upper": float(result[4]) if result[4] else None,
                        "source": "database"
                    }
                    
                cursor.close()
                conn.close()
                
            except Exception as e:
                print(f"Database forecast retrieval failed: {e}")
        
        # Fallback: Use recent SPX level for approximate bands
        try:
            spx_ticker = yf.Ticker("^GSPC")
            hist = spx_ticker.history(period="5d")
            recent_close = hist['Close'][-1]
            
            return {
                "bull_target": recent_close * 1.01,    # +1% 
                "bear_target": recent_close * 0.99,    # -1%
                "chop_lower": recent_close * 0.995,    # -0.5%
                "chop_upper": recent_close * 1.005,    # +0.5%
                "source": "fallback"
            }
        except:
            return {}
    
    def check_band_breaches(self, prices: Dict, bands: Dict) -> List[Dict]:
        """Check for forecast band breaches"""
        alerts = []
        
        if not bands or "^GSPC" not in prices:
            return alerts
            
        spx_price = prices["^GSPC"]["price"]
        
        # Check bull target breach
        if bands.get("bull_target") and spx_price >= bands["bull_target"]:
            alerts.append({
                "type": "BULL_TARGET_HIT",
                "symbol": "^GSPC",
                "price": spx_price,
                "target": bands["bull_target"],
                "message": f"SPX hit bull target: ${spx_price:.2f} >= ${bands['bull_target']:.2f}"
            })
        
        # Check bear target breach  
        if bands.get("bear_target") and spx_price <= bands["bear_target"]:
            alerts.append({
                "type": "BEAR_TARGET_HIT", 
                "symbol": "^GSPC",
                "price": spx_price,
                "target": bands["bear_target"],
                "message": f"SPX hit bear target: ${spx_price:.2f} <= ${bands['bear_target']:.2f}"
            })
        
        # Check chop band breaches
        if bands.get("chop_upper") and spx_price >= bands["chop_upper"]:
            alerts.append({
                "type": "CHOP_UPPER_BREACH",
                "symbol": "^GSPC", 
                "price": spx_price,
                "target": bands["chop_upper"],
                "message": f"SPX above chop upper: ${spx_price:.2f} >= ${bands['chop_upper']:.2f}"
            })
            
        if bands.get("chop_lower") and spx_price <= bands["chop_lower"]:
            alerts.append({
                "type": "CHOP_LOWER_BREACH",
                "symbol": "^GSPC",
                "price": spx_price, 
                "target": bands["chop_lower"],
                "message": f"SPX below chop lower: ${spx_price:.2f} <= ${bands['chop_lower']:.2f}"
            })
        
        return alerts
    
    def check_volatility_alerts(self, prices: Dict) -> List[Dict]:
        """Check for VIX/VVIX volatility alerts"""
        alerts = []
        
        # VIX spike/drop alerts
        if "^VIX" in prices:
            vix_change = prices["^VIX"]["pct_change"]
            
            if vix_change >= 15.0:
                alerts.append({
                    "type": "VIX_SPIKE",
                    "symbol": "^VIX",
                    "price": prices["^VIX"]["price"],
                    "change": vix_change,
                    "message": f"VIX spiking: {vix_change:.1f}% to {prices['^VIX']['price']:.2f}"
                })
            elif vix_change <= -10.0:
                alerts.append({
                    "type": "VIX_DROP",
                    "symbol": "^VIX", 
                    "price": prices["^VIX"]["price"],
                    "change": vix_change,
                    "message": f"VIX dropping: {vix_change:.1f}% to {prices['^VIX']['price']:.2f}"
                })
        
        # VVIX spike alerts
        if "^VVIX" in prices:
            vvix_change = prices["^VVIX"]["pct_change"]
            
            if vvix_change >= 20.0:
                alerts.append({
                    "type": "VVIX_SPIKE",
                    "symbol": "^VVIX",
                    "price": prices["^VVIX"]["price"],
                    "change": vvix_change, 
                    "message": f"VVIX spiking: {vvix_change:.1f}% to {prices['^VVIX']['price']:.2f}"
                })
        
        return alerts
    
    def store_monitoring_data(self, prices: Dict, alerts: List[Dict]):
        """Store monitoring data for analysis"""
        
        # Create monitoring log entry
        log_entry = {
            "timestamp": datetime.now().isoformat(),
            "prices": {k: {**v, "timestamp": v["timestamp"].isoformat()} for k, v in prices.items()},
            "alerts": alerts,
            "alert_count": len(alerts)
        }
        
        # Save to JSON file
        os.makedirs("output/monitoring", exist_ok=True)
        log_file = f"output/monitoring/monitoring_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, "a") as f:
            f.write(json.dumps(log_entry) + "\\n")
    
    def run_monitoring_cycle(self) -> bool:
        """Run one monitoring cycle"""
        
        print(f"=== MONITORING CYCLE {datetime.now().strftime('%H:%M:%S')} ===")
        
        # Get current prices
        prices = self.get_current_prices()
        if not prices:
            print("No price data available")
            return False
        
        # Display current prices
        for symbol, data in prices.items():
            print(f"{symbol}: ${data['price']:.2f} ({data['pct_change']:+.2f}%)")
        
        # Get forecast bands
        bands = self.get_forecast_bands()
        if bands:
            print(f"Bands source: {bands['source']}")
        
        # Check for alerts
        all_alerts = []
        all_alerts.extend(self.check_band_breaches(prices, bands))
        all_alerts.extend(self.check_volatility_alerts(prices))
        
        # Process alerts
        if all_alerts:
            print(f"🚨 {len(all_alerts)} ALERTS:")
            for alert in all_alerts:
                print(f"  {alert['type']}: {alert['message']}")
        else:
            print("✅ No alerts")
        
        # Store data
        self.store_monitoring_data(prices, all_alerts)
        
        return True

def main():
    """Main monitoring entry point"""
    print("=== REAL-TIME MARKET MONITORING ===")
    
    monitor = RealTimeMonitor()
    
    # Run single monitoring cycle
    success = monitor.run_monitoring_cycle()
    
    return 0 if success else 1

if __name__ == "__main__":
    exit(main())
'''

        with open("src/real_time_monitor.py", "w") as f:
            f.write(monitoring_code)
            
        print("✅ Generated real-time monitoring system: src/real_time_monitor.py")
        
    def create_alert_system(self):
        """Generate alert delivery system"""
        
        alert_code = '''#!/usr/bin/env python3
"""
Market Alert System
Delivers immediate notifications for band breaches and volatility events
"""

import sys
import os
from datetime import datetime
import json
import requests
from typing import Dict, List

# Add src to path
sys.path.append(os.path.join(os.path.dirname(__file__)))

class MarketAlertSystem:
    def __init__(self):
        self.slack_webhook = os.getenv('SLACK_WEBHOOK_URL')
        self.email_enabled = os.getenv('ALERT_EMAIL_ENABLED', 'false').lower() == 'true'
        
    def send_slack_alert(self, alert: Dict) -> bool:
        """Send alert to Slack"""
        
        if not self.slack_webhook:
            print("No Slack webhook configured")
            return False
            
        try:
            message = {
                "text": f"🚨 Market Alert: {alert['type']}",
                "blocks": [
                    {
                        "type": "section",
                        "text": {
                            "type": "mrkdwn",
                            "text": f"*{alert['type']}*\\n{alert['message']}"
                        }
                    },
                    {
                        "type": "context", 
                        "elements": [
                            {
                                "type": "mrkdwn",
                                "text": f"Time: {datetime.now().strftime('%H:%M:%S ET')}"
                            }
                        ]
                    }
                ]
            }
            
            response = requests.post(self.slack_webhook, json=message, timeout=10)
            
            if response.status_code == 200:
                print(f"✅ Slack alert sent: {alert['type']}")
                return True
            else:
                print(f"❌ Slack alert failed: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"❌ Slack alert error: {e}")
            return False
    
    def send_priority_alerts(self, alerts: List[Dict]) -> int:
        """Send high-priority alerts immediately"""
        
        priority_types = [
            "BULL_TARGET_HIT", "BEAR_TARGET_HIT", 
            "VIX_SPIKE", "VVIX_SPIKE"
        ]
        
        sent_count = 0
        
        for alert in alerts:
            if alert['type'] in priority_types:
                if self.send_slack_alert(alert):
                    sent_count += 1
        
        return sent_count

def main():
    """Test alert system"""
    print("=== TESTING ALERT SYSTEM ===")
    
    alerter = MarketAlertSystem()
    
    # Test alert
    test_alert = {
        "type": "SYSTEM_TEST",
        "message": "Alert system test - all systems operational",
        "timestamp": datetime.now().isoformat()
    }
    
    success = alerter.send_slack_alert(test_alert)
    return 0 if success else 1

if __name__ == "__main__":
    exit(main())
'''

        with open("src/market_alert_system.py", "w") as f:
            f.write(alert_code)
            
        print("✅ Generated alert system: src/market_alert_system.py")
        
    def create_integration_script(self):
        """Create script to integrate monitoring with existing system"""
        
        integration_code = '''#!/usr/bin/env python3
"""
Intraday Monitoring Integration
Integrates real-time monitoring with existing forecasting system
"""

import sys
import os
from datetime import datetime

sys.path.append('src')

def test_monitoring_integration():
    """Test complete monitoring integration"""
    print("=== INTRADAY MONITORING INTEGRATION TEST ===")
    
    try:
        # Test real-time monitor
        from real_time_monitor import RealTimeMonitor
        print("✅ Real-time monitor imported")
        
        monitor = RealTimeMonitor()
        print("✅ Monitor initialized")
        
        # Run one monitoring cycle
        success = monitor.run_monitoring_cycle()
        
        if success:
            print("✅ Monitoring cycle completed")
        else:
            print("⚠️  Monitoring cycle completed with warnings")
            
        # Test alert system
        from market_alert_system import MarketAlertSystem
        print("✅ Alert system imported")
        
        alerter = MarketAlertSystem()
        print("✅ Alert system initialized")
        
        print("✅ INTRADAY MONITORING INTEGRATION SUCCESS")
        return True
        
    except Exception as e:
        print(f"❌ Integration test failed: {e}")
        return False

def main():
    success = test_monitoring_integration()
    return 0 if success else 1

if __name__ == "__main__":
    exit(main())
'''

        with open("src/test_intraday_integration.py", "w") as f:
            f.write(integration_code)
            
        print("✅ Generated integration test: src/test_intraday_integration.py")

def main():
    """Build complete intraday monitoring system"""
    print("=== AUTOMATED INTRADAY MONITORING BUILDER ===")
    print("Building real-time market monitoring system...")
    
    builder = IntradayMonitoringBuilder()
    
    # Generate monitoring components
    builder.create_real_time_monitor()
    builder.create_alert_system()
    builder.create_integration_script()
    
    print("=== INTRADAY MONITORING BUILD COMPLETE ===")
    print("Generated files:")
    print("- src/real_time_monitor.py (real-time price/volatility tracking)")
    print("- src/market_alert_system.py (Slack/email alert delivery)")
    print("- src/test_intraday_integration.py (integration test)")
    
    print("\\nNext steps:")
    print("1. Configure Slack webhook URL for alerts")
    print("2. Test monitoring integration")
    print("3. Schedule regular monitoring cycles")
    
    return 0

if __name__ == "__main__":
    exit(main())