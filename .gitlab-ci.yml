# .gitlab-ci.yml â€” ZenMarket Forecaster CI/CD (perf/chopguard-v0.2.1)
# Gate: fail when weekday_gaps > 0 (toggle via ENFORCE_GAPS=strict|off)

stages: [exec, reports]

default:
  image: python:3.11
  cache:
    key: "$CI_JOB_IMAGE"
    paths:
      - .cache/pip
  before_script:
    - python --version
    - pip install --upgrade pip
    - pip install --upgrade -r vscode_snowflake_starter/requirements.txt snowflake-connector-python
    - echo "PYTHONPATH=$PYTHONPATH"

# -------------------
# Stage: exec (audit)
# -------------------
audit_cli:
  stage: exec
  variables:
    PIP_DISABLE_PIP_VERSION_CHECK: "1"
    PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
    PYTHONPATH: "$CI_PROJECT_DIR/vscode_snowflake_starter/src"
    ENFORCE_GAPS: "strict"   # set to "off" to allow gaps without failing
  script:
    - echo "=== EXEC STAGE START ==="
    - python -c "import snowflake; print('snowflake import OK')"
    - python vscode_snowflake_starter/src/exec_audit_summary.py
    - AUDIT_DIR="$(ls -dt vscode_snowflake_starter/audit_exports/stage1_exec_* | head -1)"
    - echo "AUDIT_DIR=$AUDIT_DIR" > exec.env
    - echo "EXEC_READY=true" >> exec.env
    # ---- gate: fail if weekday_gaps > 0 when ENFORCE_GAPS=strict ----
    - |
      GAPS=$(awk -F, '$1=="weekday_gaps"{print $2}' "$AUDIT_DIR/summary.csv")
      echo "weekday_gaps=$GAPS (enforce=$ENFORCE_GAPS)"
      if [ "${ENFORCE_GAPS}" = "strict" ] && [ "${GAPS:-0}" -gt 0 ]; then
        echo "âŒ Weekday gaps detected ($GAPS). Failing per policy."; exit 1
      else
        echo "âœ… Gate passed."
      fi
    - echo "=== EXEC STAGE DONE ==="
  artifacts:
    when: always
    paths:
      - "vscode_snowflake_starter/audit_exports/stage1_exec_*/REPORT_EXEC.md"
      - "vscode_snowflake_starter/audit_exports/stage1_exec_*/summary.csv"
    reports:
      dotenv: exec.env
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "perf/chopguard-v0.2.1"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# ----------------------
# Stage: reports (print)
# ----------------------
# Runs when audit PASSES (so you still get a summary in green pipelines)
publish_exec_report_success:
  stage: reports
  needs: ["audit_cli"]
  when: on_success
  variables:
    PYTHONPATH: "$CI_PROJECT_DIR/vscode_snowflake_starter/src"
  script:
    - echo "EXEC_READY=${EXEC_READY}"
    - test "${EXEC_READY}" = "true" || { echo "exec not ready"; exit 0; }
    - echo "AUDIT_DIR=${AUDIT_DIR}"
    - test -d "${AUDIT_DIR}" || { echo "no audit dir"; exit 0; }
    - echo "===== REPORT_EXEC.md (head) ====="
    - head -50 "${AUDIT_DIR}/REPORT_EXEC.md" || true
    - echo "===== summary.csv (tail) ====="
    - tail -20 "${AUDIT_DIR}/summary.csv" || true
  artifacts:
    when: always
    paths:
      - "${AUDIT_DIR:-vscode_snowflake_starter/audit_exports}/"
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "perf/chopguard-v0.2.1"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# Runs when audit FAILS (this is the case youâ€™re hitting)
publish_exec_report_on_fail:
  stage: reports
  needs: ["audit_cli"]
  when: on_failure
  variables:
    PYTHONPATH: "$CI_PROJECT_DIR/vscode_snowflake_starter/src"
  script:
    - echo "EXEC_READY=${EXEC_READY}"
    - test "${EXEC_READY}" = "true" || { echo "exec not ready"; exit 0; }
    - echo "AUDIT_DIR=${AUDIT_DIR}"
    - test -d "${AUDIT_DIR}" || { echo "no audit dir"; exit 0; }
    - echo "===== REPORT_EXEC.md (head) ====="
    - head -50 "${AUDIT_DIR}/REPORT_EXEC.md" || true
    - echo "===== summary.csv (tail) ====="
    - tail -20 "${AUDIT_DIR}/summary.csv" || true
  artifacts:
    when: always
    paths:
      - "${AUDIT_DIR:-vscode_snowflake_starter/audit_exports}/"
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "perf/chopguard-v0.2.1"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# ---------------------------------------------
# Stage: reports (Slack notifications, webhooks)
# ---------------------------------------------
# Set masked CI/CD variables in GitLab:
#   SLACK_WEBHOOK_MR            -> webhook for #zen-forecaster-mr
#   SLACK_WEBHOOK_INCIDENTS     -> webhook for #zen-forecaster-incidents

slack_mr_update:
  stage: reports
  before_script: []           # keep lightweight: no Python installs
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
  script:
    - |
      MSG=$(cat <<JSON
      {
        "text": "*MR Update*",
        "blocks": [
          {
            "type": "section",
            "text": { "type": "mrkdwn",
              "text": "*MR:* <$CI_MERGE_REQUEST_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_IID|!$CI_MERGE_REQUEST_IID> â€¢ *$CI_MERGE_REQUEST_TITLE*\n*Pipeline:* <$CI_PIPELINE_URL|#$CI_PIPELINE_ID> â€¢ *Status:* $CI_PIPELINE_STATUS"
            }
          }
        ]
      }
      JSON
      )
      test -n "$SLACK_WEBHOOK_MR" || { echo "SLACK_WEBHOOK_MR not set"; exit 0; }
      curl -sS -X POST -H 'Content-type: application/json' --data "$MSG" "$SLACK_WEBHOOK_MR" || true

slack_incident_on_fail:
  stage: reports
  needs: ["audit_cli"]        # ensure it runs after audit, even if audit failed
  when: on_failure            # guaranteed to run after a failure
  before_script: []           # keep lightweight
  script:
    - |
      AUD="vscode_snowflake_starter/audit_exports"
      LAST_DIR=$(ls -dt ${AUD}/stage1_exec_* 2>/dev/null | head -1 || true)
      LAST_SUM="${LAST_DIR:+$LAST_DIR/summary.csv}"
      GAPS=$([ -f "$LAST_SUM" ] && awk -F, '$1=="weekday_gaps"{print $2}' "$LAST_SUM" || echo "n/a")
      MSG=$(cat <<JSON
      {
        "text": "ðŸš¨ *Pipeline FAILED* for *$CI_PROJECT_PATH* on *$CI_COMMIT_BRANCH*",
        "blocks": [
          { "type": "header", "text": { "type": "plain_text", "text": "ðŸš¨ Pipeline Failed" } },
          { "type": "section",
            "fields": [
              { "type": "mrkdwn", "text": "*Pipeline:*\n<$CI_PIPELINE_URL|#$CI_PIPELINE_ID>" },
              { "type": "mrkdwn", "text": "*Commit:*\n<$CI_PROJECT_URL/-/commit/$CI_COMMIT_SHA|${CI_COMMIT_SHORT_SHA:-$CI_COMMIT_SHA}>" },
              { "type": "mrkdwn", "text": "*weekday_gaps:*\n$GAPS" }
            ]
          }
        ]
      }
      JSON
      )
      test -n "$SLACK_WEBHOOK_INCIDENTS" || { echo "SLACK_WEBHOOK_INCIDENTS not set"; exit 0; }
      curl -sS -X POST -H 'Content-type: application/json' --data "$MSG" "$SLACK_WEBHOOK_INCIDENTS" || true
